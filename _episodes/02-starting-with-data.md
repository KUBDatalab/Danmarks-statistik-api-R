---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-starting-with-data.md in _episodes_rmd/
title: "Starting with Data"
teaching: 50
exercises: 30
questions:
- "What is a data.frame?"
- "How can I read a complete csv file into R?"
- "How can I get basic summary information about my dataset?"
- "How can I change the way R treats strings in my dataset?"
- "Why would I want strings to be treated differently?"
- "How are dates represented in R and how can I change the format?"
objectives:
- "Describe what a data frame is."
- "Load external data from a .csv file into a data frame."
- "Summarize the contents of a data frame."
- "Subset and extract values from data frames."
- "Describe the difference between a factor and a string."
- "Convert between strings and factors."
- "Reorder and rename factors."
- "Change how character strings are handled in a data frame."
- "Examine and change date formats."
keypoints:
- "Use read_csv to read tabular data in R."
- "Use factors to represent categorical data in R."
source: Rmd
---




## What are data frames and tibbles?

Data frames are the _de facto_ data structure for tabular data in `R`, and what
we use for data processing, statistics, and plotting.

A data frame is the representation of data in the format of a table where the
columns are vectors that all have the same length. Data frames are analogous to
the more familiar spreadsheet in programs such as Excel, with one key difference.
Because columns are vectors,
each column must contain a single type of data (e.g., characters, integers,
factors). For example, here is a figure depicting a data frame comprising a
numeric, a character, and a logical vector.

![A 3 by 3 data frame with columns showing numeric, character and logical values.](../fig/data-frame.svg)

Data frames can be created by hand, but most commonly they are generated by the
functions `read_csv()` or `read_table()`; in other words, when importing
spreadsheets from your hard drive (or the web). We will now demonstrate how to
import tabular data using `read_csv()`.



## Importing data

You are going load the data in R's memory using the function `read_csv()`
from the **`readr`** package, which is part of the **`tidyverse`**; learn
more about the **`tidyverse`** collection of packages
[here](https://www.tidyverse.org/).
**`readr`** gets installed as part as the **`tidyverse`** installation.
When you load  the **`tidyverse`** (`library(tidyverse)`), the core packages
(the packages used in most data analyses) get loaded, including **`readr`**.

Even with the use of an RStudio project, it can be difficult to learn how to
specify paths to file locations. Enter the **here** package! The here package
creates paths relative to the top-level directory (your RStudio project). These
relative paths work *regardless* of where the associated source file lives
inside your project, like analysis projects with data and reports in different
subdirectories.  This is an important contrast to using `setwd()`, which 
depends on the way you order your files on your computer. 



Before we can use the `read_csv()` and `here()` functions, we need to load the 
tidyverse and here packages.

Also, if you recall, the missing data is encoded as "NULL" in the dataset.
We'll tell it to the function, so R will automatically convert all the "NULL"
entries in the dataset into `NA`.


~~~
library(tidyverse)
library(here)

interviews <- read_csv(
  here("data", "SAFI_clean.csv"), 
  na = "NULL")
~~~
{: .language-r}

In the above code, we notice the `here()` function takes folder and file names
as inputs (e.g., `"data"`, `"SAFI_clean.csv"`), each enclosed in quotations 
(`""`) and separated by a comma. The `here()` will accept as many names as are
necessary to navigate to a particular file 
(e.g., `here("analysis", "data", "surveys", "clean", "SAFI_clean.csv)`). 



The second statement in the code above creates a data frame but doesn't output
any data because, as you might recall, assignments (`<-`) don't display
anything. (Note, however, that `read_csv` may show informational
text about the data frame that is created.) If we want to check that our data
has been loaded, we can see the contents of the data frame by typing its name:
`interviews` in the console.


~~~
interviews
## Try also
## view(interviews)
## head(interviews)
~~~
{: .language-r}



~~~
# A tibble: 131 × 14
   key_ID village interview_date      no_membrs years_liv respondent_wall… rooms
    <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>            <dbl>
 1      1 God     2016-11-17 00:00:00         3         4 muddaub              1
 2      1 God     2016-11-17 00:00:00         7         9 muddaub              1
 3      3 God     2016-11-17 00:00:00        10        15 burntbricks          1
 4      4 God     2016-11-17 00:00:00         7         6 burntbricks          1
 5      5 God     2016-11-17 00:00:00         7        40 burntbricks          1
 6      6 God     2016-11-17 00:00:00         3         3 muddaub              1
 7      7 God     2016-11-17 00:00:00         6        38 muddaub              1
 8      8 Chirod… 2016-11-16 00:00:00        12        70 burntbricks          3
 9      9 Chirod… 2016-11-16 00:00:00         8         6 burntbricks          1
10     10 Chirod… 2016-12-16 00:00:00        12        23 burntbricks          5
# … with 121 more rows, and 7 more variables: memb_assoc <chr>,
#   affect_conflicts <chr>, liv_count <dbl>, items_owned <chr>, no_meals <dbl>,
#   months_lack_food <chr>, instanceID <chr>
~~~
{: .output}

> ## Note
>
> `read_csv()` assumes that fields are delimited by commas. However, in several
> countries, the comma is used as a decimal separator and the semicolon (;) is
> used as a field delimiter. If you want to read in this type of files in R,
> you can use the `read_csv2` function. It behaves exactly like `read_csv` but
> uses different parameters for the decimal and the field separators. If you are
> working with another format, they can be both specified by the user. Check out
> the help for `read_csv()` by typing `?read_csv` to learn more. There is also
> the `read_tsv()` for tab-separated data files, and `read_delim()` allows you
> to specify more details about the structure of your file.
{: .callout}

Note that `read_csv()` actually loads the data as a tibble.
A tibble is an extension of `R` data frames used by the **`tidyverse`**. When
the data is read using `read_csv()`, it is stored in an object of class 
`tbl_df`, `tbl`,  and `data.frame`. You can see the class of an object with


~~~
class(interviews)
~~~
{: .language-r}



~~~
[1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame" 
~~~
{: .output}

As a `tibble`, the type of data included in each column is listed in an
abbreviated fashion below the column names. For instance, here `key_ID` is a
column of floating point numbers (abbreviated `<dbl>` for the word 'double'),
`village` is a column of characters (`<chr>`) and the `interview_date` is a 
column in the "date and time" format (`<dttm>`).

## Inspecting data frames

When calling a `tbl_df` object (like `interviews` here), there is already a lot
of information about our data frame being displayed such as the number of rows,
the number of columns, the names of the columns, and as we just saw the class of
data stored in each column. However, there are functions to extract this
information from data frames.  Here is a non-exhaustive list of some of these
functions. Let's try them out!

Size:  

* `dim(interviews)` - returns a vector with the number of rows as the first
element, and the number of columns as the second element (the **dim**ensions of
the object)
* `nrow(interviews)` - returns the number of rows
* `ncol(interviews)` - returns the number of columns

Content: 

* `head(interviews)` - shows the first 6 rows
* `tail(interviews)` - shows the last 6 rows

Names: 

* `names(interviews)` - returns the column names (synonym of `colnames()` for
`data.frame` objects)

Summary:  

* `str(interviews)` - structure of the object and information about the class,
length and content of each column
* `summary(interviews)` - summary statistics for each column
* `glimpse(interviews)` - returns the number of columns and rows of the tibble,
the names and class of each column, and previews as many values will fit on the
screen. Unlike the other inspecting functions listed above, `glimpse()` is not a
"base R" function so you need to have the `dplyr` or `tibble` packages loaded to
be able to execute it.

Note: most of these functions are "generic." They can be used on other types of
objects besides data frames or tibbles.


## Indexing and subsetting data frames

Our `interviews` data frame has rows and columns (it has 2 dimensions).
In practice, we may not need the entire data frame; for instance, we may only
be interested in a subset of the observations (the rows) or a particular set
of variables (the columns). If we want to
extract some specific data from it, we need to specify the "coordinates" we
want from it. Row numbers come first, followed by column numbers.

> ## Tip
> Indexing a `tibble` with `[` always results in a `tibble`.
> However, note this is not true in general for data frames, so be careful!
> Different ways of specifying these coordinates can lead to results with
> different classes. This is covered in the Software Carpentry lesson
> [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/).
{: .callout}



~~~
## first element in the first column of the tibble
interviews[1, 1]
~~~
{: .language-r}



~~~
# A tibble: 1 × 1
  key_ID
   <dbl>
1      1
~~~
{: .output}



~~~
## first element in the 6th column of the tibble 
interviews[1, 6]
~~~
{: .language-r}



~~~
# A tibble: 1 × 1
  respondent_wall_type
  <chr>               
1 muddaub             
~~~
{: .output}



~~~
## first column of the tibble (as a vector)
interviews[[1]]
~~~
{: .language-r}



~~~
  [1]   1   1   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
 [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  21  54
 [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71 127
 [73] 133 152 153 155 178 177 180 181 182 186 187 195 196 197 198 201 202  72
 [91]  73  76  83  85  89 101 103 102  78  80 104 105 106 109 110 113 118 125
[109] 119 115 108 116 117 144 143 150 159 160 165 166 167 174 175 189 191 192
[127] 126 193 194 199 200
~~~
{: .output}



~~~
## first column of the tibble
interviews[1]
~~~
{: .language-r}



~~~
# A tibble: 131 × 1
   key_ID
    <dbl>
 1      1
 2      1
 3      3
 4      4
 5      5
 6      6
 7      7
 8      8
 9      9
10     10
# … with 121 more rows
~~~
{: .output}



~~~
## first three elements in the 7th column of the tibble
interviews[1:3, 7]
~~~
{: .language-r}



~~~
# A tibble: 3 × 1
  rooms
  <dbl>
1     1
2     1
3     1
~~~
{: .output}



~~~
## the 3rd row of the tibble
interviews[3, ]
~~~
{: .language-r}



~~~
# A tibble: 1 × 14
  key_ID village interview_date      no_membrs years_liv respondent_wall_… rooms
   <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>             <dbl>
1      3 God     2016-11-17 00:00:00        10        15 burntbricks           1
# … with 7 more variables: memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
~~~
{: .output}



~~~
## equivalent to head_interviews <- head(interviews)
head_interviews <- interviews[1:6, ]
~~~
{: .language-r}

`:` is a special function that creates numeric vectors of integers in increasing
or decreasing order, test `1:10` and `10:1` for instance.

You can also exclude certain indices of a data frame using the "`-`" sign:


~~~
interviews[, -1]          # The whole tibble, except the first column
~~~
{: .language-r}



~~~
# A tibble: 131 × 13
   village  interview_date      no_membrs years_liv respondent_wall_type rooms
   <chr>    <dttm>                  <dbl>     <dbl> <chr>                <dbl>
 1 God      2016-11-17 00:00:00         3         4 muddaub                  1
 2 God      2016-11-17 00:00:00         7         9 muddaub                  1
 3 God      2016-11-17 00:00:00        10        15 burntbricks              1
 4 God      2016-11-17 00:00:00         7         6 burntbricks              1
 5 God      2016-11-17 00:00:00         7        40 burntbricks              1
 6 God      2016-11-17 00:00:00         3         3 muddaub                  1
 7 God      2016-11-17 00:00:00         6        38 muddaub                  1
 8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks              3
 9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks              1
10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks              5
# … with 121 more rows, and 7 more variables: memb_assoc <chr>,
#   affect_conflicts <chr>, liv_count <dbl>, items_owned <chr>, no_meals <dbl>,
#   months_lack_food <chr>, instanceID <chr>
~~~
{: .output}



~~~
interviews[-c(7:131), ]   # Equivalent to head(interviews)
~~~
{: .language-r}



~~~
# A tibble: 6 × 14
  key_ID village interview_date      no_membrs years_liv respondent_wall_… rooms
   <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>             <dbl>
1      1 God     2016-11-17 00:00:00         3         4 muddaub               1
2      1 God     2016-11-17 00:00:00         7         9 muddaub               1
3      3 God     2016-11-17 00:00:00        10        15 burntbricks           1
4      4 God     2016-11-17 00:00:00         7         6 burntbricks           1
5      5 God     2016-11-17 00:00:00         7        40 burntbricks           1
6      6 God     2016-11-17 00:00:00         3         3 muddaub               1
# … with 7 more variables: memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
~~~
{: .output}

`tibble`s can be subset by calling indices (as shown previously), but also by
calling their column names directly:


~~~
interviews["village"]       # Result is a tibble

interviews[, "village"]     # Result is a tibble

interviews[["village"]]     # Result is a vector

interviews$village          # Result is a vector
~~~
{: .language-r}

In RStudio, you can use the autocompletion feature to get the full and correct
names of the columns.

> ## Exercise
>
> 1. Create a tibble (`interviews_100`) containing only the data in
>    row 100 of the `interviews` dataset.
>
> 2. Notice how `nrow()` gave you the number of rows in the tibble?
>
>      * Use that number to pull out just that last row in the tibble.
>      * Compare that with what you see as the last row using `tail()` to make
>        sure it's meeting expectations.
>      * Pull out that last row using `nrow()` instead of the row number.
>      * Create a new tibble (`interviews_last`) from that last row.
>
> 3. Using the number of rows in the interviews dataset that you found in
>    question 2, extract the row that is in the middle of the dataset. Store
>    the content of this middle row in an object named `interviews_middle`.
>    (hint: This dataset has an odd number of rows, so finding the middle is a
>    bit trickier than dividing n_rows by 2. Use the median( ) function and what
>    you've learned about sequences in R to extract the middle row!
>
> 4. Combine `nrow()` with the `-` notation above to reproduce the behavior of
>    `head(interviews)`, keeping just the first through 6th rows of the
>    interviews dataset.
>
> > ## Solution
> >
> > 
> > ~~~
> > ## 1.
> > interviews_100 <- interviews[100, ]
> > ## 2.
> > # Saving `n_rows` to improve readability and reduce duplication
> > n_rows <- nrow(interviews)
> > interviews_last <- interviews[n_rows, ]
> > ## 3.
> > interviews_middle <- interviews[median(1:n_rows), ]
> > ## 4.
> > interviews_head <- interviews[-(7:n_rows), ]
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}


## Factors

R has a special data class, called factor, to deal with categorical data that
you may encounter when creating plots or doing statistical analyses. Factors are
very useful and actually contribute to making R particularly well suited to
working with data. So we are going to spend a little time introducing them.

Factors represent categorical data. They are stored as integers associated with
labels and they can be ordered (ordinal) or unordered (nominal). Factors
create a structured  relation between the different levels (values) of a
categorical variable, such as days of the week or responses to a question in
a survey. This can make it easier to see how one element relates to the
other elements in a column. While factors look (and often behave) like
character vectors, they are actually treated as integer vectors by `R`. So
you need to be very careful when treating them as strings.

Once created, factors can only contain a pre-defined set of values, known as
*levels*. By default, R always sorts levels in alphabetical order. For
instance, if you have a factor with 2 levels:


~~~
respondent_floor_type <- factor(c("earth", "cement", "cement", "earth"))
~~~
{: .language-r}

R will assign `1` to the level `"cement"` and `2` to the level `"earth"`
(because `c` comes before `e`, even though the first element in this vector is
`"earth"`). You can see this by using the function `levels()` and you can find
the number of levels using `nlevels()`:


~~~
levels(respondent_floor_type)
~~~
{: .language-r}



~~~
[1] "cement" "earth" 
~~~
{: .output}



~~~
nlevels(respondent_floor_type)
~~~
{: .language-r}



~~~
[1] 2
~~~
{: .output}

Sometimes, the order of the factors does not matter. Other times you might want
to specify the order because it is meaningful (e.g., "low", "medium", "high").
It may improve your visualization, or it may be required by a particular type of
analysis. Here, one way to reorder our levels in the `respondent_floor_type`
vector would be:


~~~
respondent_floor_type # current order
~~~
{: .language-r}



~~~
[1] earth  cement cement earth 
Levels: cement earth
~~~
{: .output}



~~~
respondent_floor_type <- factor(respondent_floor_type, 
                                levels = c("earth", "cement"))

respondent_floor_type # after re-ordering
~~~
{: .language-r}



~~~
[1] earth  cement cement earth 
Levels: earth cement
~~~
{: .output}

In R's memory, these factors are represented by integers (1, 2), but are more
informative than integers because factors are self describing: `"cement"`,
`"earth"` is more descriptive than `1`, and `2`. Which one is "earth"? You
wouldn't be able to tell just from the integer data. Factors, on the other hand,
have this information built in. It is particularly helpful when there are many
levels. It also makes renaming levels easier. Let's say we made a mistake and
need to recode "cement" to "brick".


~~~
levels(respondent_floor_type)
~~~
{: .language-r}



~~~
[1] "earth"  "cement"
~~~
{: .output}



~~~
levels(respondent_floor_type)[2] <- "brick"

levels(respondent_floor_type)
~~~
{: .language-r}



~~~
[1] "earth" "brick"
~~~
{: .output}



~~~
respondent_floor_type
~~~
{: .language-r}



~~~
[1] earth brick brick earth
Levels: earth brick
~~~
{: .output}

So far, your factor is unordered, like a nominal variable. R does not know the
difference between a nominal and an ordinal variable. You make your factor an
ordered factor by using the `ordered=TRUE` option inside your factor function.
Note how the reported levels changed from the unordered factor above to the
ordered version below. Ordered levels use the less than sign `<` to denote
level ranking.


~~~
respondent_floor_type_ordered <- factor(respondent_floor_type, 
                                        ordered = TRUE)

respondent_floor_type_ordered # after setting as ordered factor
~~~
{: .language-r}



~~~
[1] earth brick brick earth
Levels: earth < brick
~~~
{: .output}


### Converting factors

If you need to convert a factor to a character vector, you use
`as.character(x)`.


~~~
as.character(respondent_floor_type)
~~~
{: .language-r}



~~~
[1] "earth" "brick" "brick" "earth"
~~~
{: .output}

Converting factors where the levels appear as numbers (such as concentration
levels, or years) to a numeric vector is a little trickier. The `as.numeric()`
function returns the index values of the factor, not its levels, so it will
result in an entirely new (and unwanted in this case) set of numbers.
One method to avoid this is to convert factors to characters, and then to
numbers. Another method is to use the `levels()` function. Compare:


~~~
year_fct <- factor(c(1990, 1983, 1977, 1998, 1990))

as.numeric(year_fct)                     # Wrong! And there is no warning...
~~~
{: .language-r}



~~~
[1] 3 2 1 4 3
~~~
{: .output}



~~~
as.numeric(as.character(year_fct))       # Works...
~~~
{: .language-r}



~~~
[1] 1990 1983 1977 1998 1990
~~~
{: .output}



~~~
as.numeric(levels(year_fct))[year_fct]   # The recommended way.
~~~
{: .language-r}



~~~
[1] 1990 1983 1977 1998 1990
~~~
{: .output}

Notice that in the recommended `levels()` approach, three important steps occur:

* We obtain all the factor levels using `levels(year_fct)`
* We convert these levels to numeric values using `as.numeric(levels(year_fct))`
* We then access these numeric values using the underlying integers of the
vector `year_fct` inside the square brackets

### Renaming factors

When your data is stored as a factor, you can use the `plot()` function to get a
quick glance at the number of observations represented by each factor level.
Let's extract the `memb_assoc` column from our data frame, convert it into a
factor, and use it to look at the number of interview respondents who were or
were not members of an irrigation association:


~~~
## create a vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

## convert it into a factor
memb_assoc <- as.factor(memb_assoc)

## let's see what it looks like
memb_assoc
~~~
{: .language-r}



~~~
  [1] <NA> yes  <NA> <NA> <NA> <NA> no   yes  no   no   <NA> yes  no   <NA> yes 
 [16] <NA> <NA> <NA> <NA> <NA> no   <NA> <NA> no   no   no   <NA> no   yes  <NA>
 [31] <NA> yes  no   yes  yes  yes  <NA> yes  <NA> yes  <NA> no   no   <NA> no  
 [46] no   yes  <NA> <NA> yes  <NA> no   yes  no   <NA> yes  no   no   <NA> no  
 [61] yes  <NA> <NA> <NA> no   yes  no   no   no   no   yes  <NA> no   yes  <NA>
 [76] <NA> yes  no   no   yes  no   no   yes  no   yes  no   no   <NA> yes  yes 
 [91] yes  yes  yes  no   no   no   no   yes  no   no   yes  yes  no   <NA> no  
[106] no   <NA> no   no   <NA> no   <NA> <NA> no   no   no   no   yes  no   no  
[121] no   no   no   no   no   no   no   no   no   yes  <NA>
Levels: no yes
~~~
{: .output}



~~~
## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
~~~
{: .language-r}

<img src="../fig/rmd-02-factor-plot-default-order-1.png" title="Yes/no bar graph showing number of individuals who are members of irrigation association" alt="Yes/no bar graph showing number of individuals who are members of irrigation association" width="612" style="display: block; margin: auto;" />

Looking at the plot compared to the output of the vector, we can see that in
addition to "no"s and "yes"s, there are some respondents for which the
information about whether they were part of an irrigation association hasn't
been recorded, and encoded as missing data. They do not appear on the plot.
Let's encode them differently so they can counted and visualized in our plot.



~~~
## Let's recreate the vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

## replace the missing data with "undetermined"
memb_assoc[is.na(memb_assoc)] <- "undetermined"

## convert it into a factor
memb_assoc <- as.factor(memb_assoc)

## let's see what it looks like
memb_assoc
~~~
{: .language-r}



~~~
  [1] undetermined yes          undetermined undetermined undetermined
  [6] undetermined no           yes          no           no          
 [11] undetermined yes          no           undetermined yes         
 [16] undetermined undetermined undetermined undetermined undetermined
 [21] no           undetermined undetermined no           no          
 [26] no           undetermined no           yes          undetermined
 [31] undetermined yes          no           yes          yes         
 [36] yes          undetermined yes          undetermined yes         
 [41] undetermined no           no           undetermined no          
 [46] no           yes          undetermined undetermined yes         
 [51] undetermined no           yes          no           undetermined
 [56] yes          no           no           undetermined no          
 [61] yes          undetermined undetermined undetermined no          
 [66] yes          no           no           no           no          
 [71] yes          undetermined no           yes          undetermined
 [76] undetermined yes          no           no           yes         
 [81] no           no           yes          no           yes         
 [86] no           no           undetermined yes          yes         
 [91] yes          yes          yes          no           no          
 [96] no           no           yes          no           no          
[101] yes          yes          no           undetermined no          
[106] no           undetermined no           no           undetermined
[111] no           undetermined undetermined no           no          
[116] no           no           yes          no           no          
[121] no           no           no           no           no          
[126] no           no           no           no           yes         
[131] undetermined
Levels: no undetermined yes
~~~
{: .output}



~~~
## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
~~~
{: .language-r}

<img src="../fig/rmd-02-factor-plot-reorder-1.png" title="plot of chunk factor-plot-reorder" alt="plot of chunk factor-plot-reorder" width="612" style="display: block; margin: auto;" />


> ## Exercise
>
> * Rename the levels of the factor to have the first letter in uppercase:
>   "No","Undetermined", and "Yes".
>
> * Now that we have renamed the factor level to "Undetermined", can you
>   recreate the barplot such that "Undetermined" is last (after "Yes")?
>
> > ## Solution
> >
> > 
> > ~~~
> > ## Rename levels. Note we need to keep the original level ordering when renaming.
> > levels(memb_assoc) <- c("No", "Undetermined", "Yes")
> > ## Reorder levels. Note we need to use the new level names.
> > memb_assoc <- factor(memb_assoc, levels = c("No", "Yes", "Undetermined"))
> > plot(memb_assoc)
> > ~~~
> > {: .language-r}
> > 
> > <img src="../fig/rmd-02-factor-plot-exercise-1.png" title="bar graph showing number of individuals who are members of irrigation association, including undetermined option" alt="bar graph showing number of individuals who are members of irrigation association, including undetermined option" width="612" style="display: block; margin: auto;" />
> {: .solution}
{: .challenge}

## Formatting Dates

One of the most common issues that new (and experienced!) R users have is
converting date and time information into a variable that is appropriate and
usable during analyses. As a reminder from earlier in this lesson, the best
practice for dealing with date data is to ensure that each component of your
date is stored as a separate variable. In our dataset, we have a
column `interview_date` which contains information about the
year, month, and day that the interview was conducted. Let's
convert those dates into three separate columns.


~~~
str(interviews)
~~~
{: .language-r}
We are going to use the package **`lubridate`**, which is included in the
**`tidyverse`** installation but not loaded by default, so we have to load
it explicitly with `library(lubridate)`.

Start by loading the required package:


~~~
library(lubridate)
~~~
{: .language-r}

The lubridate function `ymd()` takes a vector representing year, month, and day,
and converts it to a `Date` vector. `Date` is a class of data recognized by R as
being a date and can be manipulated as such. The argument that the function
requires is flexible, but, as a best practice, is a character vector formatted
as "YYYY-MM-DD".

Let's extract our `interview_date` column and inspect the structure:


~~~
dates <- interviews$interview_date
str(dates)
~~~
{: .language-r}



~~~
 POSIXct[1:131], format: "2016-11-17" "2016-11-17" "2016-11-17" "2016-11-17" "2016-11-17" ...
~~~
{: .output}

When we imported the data in R, `read_csv()` recognized that this column
contained date information. We can now use the `day()`, `month()` and  `year()`
functions to extract this information from the date, and create new columns in
our data frame to store it:



~~~
interviews$day <- day(dates)
interviews$month <- month(dates)
interviews$year <- year(dates)
interviews
~~~
{: .language-r}



~~~
# A tibble: 131 × 17
   key_ID village interview_date      no_membrs years_liv respondent_wall… rooms
    <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>            <dbl>
 1      1 God     2016-11-17 00:00:00         3         4 muddaub              1
 2      1 God     2016-11-17 00:00:00         7         9 muddaub              1
 3      3 God     2016-11-17 00:00:00        10        15 burntbricks          1
 4      4 God     2016-11-17 00:00:00         7         6 burntbricks          1
 5      5 God     2016-11-17 00:00:00         7        40 burntbricks          1
 6      6 God     2016-11-17 00:00:00         3         3 muddaub              1
 7      7 God     2016-11-17 00:00:00         6        38 muddaub              1
 8      8 Chirod… 2016-11-16 00:00:00        12        70 burntbricks          3
 9      9 Chirod… 2016-11-16 00:00:00         8         6 burntbricks          1
10     10 Chirod… 2016-12-16 00:00:00        12        23 burntbricks          5
# … with 121 more rows, and 10 more variables: memb_assoc <chr>,
#   affect_conflicts <chr>, liv_count <dbl>, items_owned <chr>, no_meals <dbl>,
#   months_lack_food <chr>, instanceID <chr>, day <int>, month <dbl>,
#   year <dbl>
~~~
{: .output}

Notice the three new columns at the end of our data frame.

In our example above, the `interview_date` column was read in correctly as a
`Date` variable but generally that is not the case. Date columns are often read
in as `character` variables and one can use the `as_date()` function to convert
them to the appropriate `Date/POSIXct`format.

Let's say we have a vector of dates in character format:


~~~
char_dates <- c("7/31/2012", "8/9/2014", "4/30/2016")
str(char_dates)
~~~
{: .language-r}



~~~
 chr [1:3] "7/31/2012" "8/9/2014" "4/30/2016"
~~~
{: .output}

We can convert this vector to dates as :


~~~
as_date(char_dates, format = "%m/%d/%Y")
~~~
{: .language-r}



~~~
[1] "2012-07-31" "2014-08-09" "2016-04-30"
~~~
{: .output}

Argument `format` tells the function the order to parse the characters and
identify the month, day and year. The format above is the equivalent of 
mm/dd/yyyy. A wrong format can lead to parsing errors or incorrect results.

For example, observe what happens when we use a lower case y instead of upper
case Y for the year. 

~~~
as_date(char_dates, format = "%m/%d/%y")
~~~
{: .language-r}



~~~
[1] "2020-07-31" "2020-08-09" "2020-04-30"
~~~
{: .output}

Here, the `%y` part of the format stands for a two-digit year instead of a
four-digit year, and this leads to parsing errors.

Or in the following example, observe what happens when the month and day
elements of the format are switched.


~~~
as_date(char_dates, format = "%d/%m/%y")
~~~
{: .language-r}



~~~
[1] NA           "2020-09-08" NA          
~~~
{: .output}

Since there is no month numbered 30 or 31, the first and third dates cannot be
parsed.

We can also use functions `ymd()`, `mdy()` or `dmy()` to convert character
variables to date.


~~~
mdy(char_dates)
~~~
{: .language-r}



~~~
[1] "2012-07-31" "2014-08-09" "2016-04-30"
~~~
{: .output}


<!-- --- -->
<!-- title: "Data Wrangling with dplyr and tidyr" -->
<!-- keypoints: -->
<!-- - Use the `dplyr` package to manipulate dataframes. -->
<!-- - Use `select()` to choose variables from a dataframe. -->
<!-- - Use `filter()` to choose data based on values. -->
<!-- - Use `group_by()` and `summarize()` to work with subsets of data. -->
<!-- - Use `mutate()` to create new variables. -->
<!-- - Use the `tidyr` package to change the layout of dataframes. -->
<!-- - Use `pivot_wider()` to go from long to wide format. -->
<!-- - Use `pivot_longer()` to go from wide to long format. -->
<!-- objectives: -->
<!-- - Describe the purpose of an R package and the **`dplyr`** and **`tidyr`** packages. -->
<!-- - Select certain columns in a dataframe with the **`dplyr`** function `select`. -->
<!-- - Select certain rows in a dataframe according to filtering conditions with the **`dplyr`** -->
<!--   function `filter`. -->
<!-- - Link the output of one **`dplyr`** function to the input of another function with -->
<!--   the 'pipe' operator `%>%`. -->
<!-- - Add new columns to a dataframe that are functions of existing columns with `mutate`. -->
<!-- - Use the split-apply-combine concept for data analysis. -->
<!-- - Use `summarize`, `group_by`, and `count` to split a dataframe into groups of observations, -->
<!--   apply a summary statistics for each group, and then combine the results. -->
<!-- - Describe the concept of a wide and a long table format and for which purpose those -->
<!--   formats are useful. -->
<!-- - Describe the roles of variable names and their associated values when a table is -->
<!--   reshaped. -->
<!-- - Reshape a dataframe from long to wide format and back with the `pivot_wider` and -->
<!--   `pivot_longer` commands from the **`tidyr`** package. -->
<!-- - Export a dataframe to a csv file. -->
<!-- questions: -->
<!-- - How can I select specific rows and/or columns from a dataframe? -->
<!-- - How can I combine multiple commands into a single command? -->
<!-- - How can I create new columns or remove existing columns from a dataframe? -->
<!-- - How can I reformat a dataframe to meet my needs? -->
<!-- teaching: 50 -->
<!-- exercises: 30 -->
<!-- source: Rmd -->
<!-- --- -->


<!-- ```{r, include = FALSE} -->
<!-- source("../bin/chunk-options.R") -->
<!-- knitr_fig_path("03-") -->
<!-- source("../bin/download_data.R") -->
<!-- ``` -->

<!-- **`dplyr`** is a package for making tabular data wrangling easier by using a -->
<!-- limited set of functions that can be combined to extract and summarize insights -->
<!-- from your data. It pairs nicely with **`tidyr`** which enables you to swiftly -->
<!-- convert between different data formats (long vs. wide) for plotting and analysis. -->

<!-- Similarly to **`readr`**, **`dplyr`** and **`tidyr`** are also part of the -->
<!-- tidyverse. These packages were loaded in R's memory when we called -->
<!-- `library(tidyverse)` earlier. -->

<!-- > ## Note -->
<!-- > -->
<!-- > The packages in the tidyverse, namely **`dplyr`**, **`tidyr`** and **`ggplot2`** -->
<!-- > accept both the British (e.g. *summarise*) and American (e.g. *summarize*) spelling -->
<!-- > variants of different function and option names. For this lesson, we utilize -->
<!-- > the American spellings of different functions; however, feel free to use -->
<!-- > the regional variant for where you are teaching. -->
<!-- {: .callout} -->

<!-- ## What is an R package? -->

<!-- The package **`dplyr`** provides easy tools for the most common data -->
<!-- wrangling tasks. It is built to work directly with dataframes, with many -->
<!-- common tasks optimized by being written in a compiled language (C++) (not all R -->
<!-- packages are written in R!). -->

<!-- The package **`tidyr`** addresses the common problem of wanting to reshape your -->
<!-- data for plotting and use by different R functions. Sometimes we want data sets -->
<!-- where we have one row per measurement. Sometimes we want a dataframe where each -->
<!-- measurement type has its own column, and rows are instead more aggregated -->
<!-- groups. Moving back and forth between these formats is nontrivial, and -->
<!-- **`tidyr`** gives you tools for this and more sophisticated data wrangling. -->

<!-- But there are also packages available for a wide range of tasks including -->
<!-- building plots (**`ggplot2`**, which we'll see later), downloading data from the -->
<!-- NCBI database, or performing statistical analysis on your data set. Many -->
<!-- packages such as these are housed on, and downloadable from, the -->
<!-- **C**omprehensive **R** **A**rchive **N**etwork (CRAN) using `install.packages`. -->
<!-- This function makes the package accessible by your R installation with the -->
<!-- command `library()`, as you did with `tidyverse` earlier. -->

<!-- To easily access the documentation for a package within R or RStudio, use -->
<!-- `help(package = "package_name")`. -->

<!-- To learn more about **`dplyr`** and **`tidyr`** after the workshop, you may want -->
<!-- to check out this [handy data transformation with **`dplyr`** cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf) -->
<!-- and this [one about **`tidyr`**](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf). -->

<!-- ## Learning **`dplyr`** and **`tidyr`** -->

<!-- To make sure everyone will use the same dataset for this lesson, we'll read -->
<!-- again the SAFI dataset that we downloaded earlier. -->

<!-- ```{r, results = 'hide', purl = FALSE, message = FALSE} -->

<!-- ## load the tidyverse -->
<!-- library(tidyverse) -->
<!-- library(here) -->

<!-- interviews <- read_csv(here("data", "SAFI_clean.csv"), na = "NULL") -->

<!-- ## inspect the data -->
<!-- interviews -->

<!-- ## preview the data -->
<!-- # view(interviews) -->
<!-- ``` -->

<!-- We're going to learn some of the most common **`dplyr`** functions: -->

<!-- - `select()`: subset columns -->
<!-- - `filter()`: subset rows on conditions -->
<!-- - `mutate()`: create new columns by using information from other columns -->
<!-- - `group_by()` and `summarize()`: create summary statistics on grouped data -->
<!-- - `arrange()`: sort results -->
<!-- - `count()`: count discrete values -->

<!-- ## Selecting columns and filtering rows -->

<!-- To select columns of a dataframe, use `select()`. The first argument to this -->
<!-- function is the dataframe (`interviews`), and the subsequent arguments are the -->
<!-- columns to keep, separated by commas. Alternatively, if you are selecting -->
<!-- columns adjacent to each other, you can use a `:` to select a range of columns, -->
<!-- read as "select columns from ___ to ___." -->

<!-- ```{r, results = 'hide', purl = FALSE} -->
<!-- # to select columns throughout the dataframe -->
<!-- select(interviews, village, no_membrs, months_lack_food) -->
<!-- # to select a series of connected columns -->
<!-- select(interviews, village:respondent_wall_type) -->
<!-- ``` -->

<!-- To choose rows based on specific criteria, we can use the `filter()` function. -->
<!-- The argument after the dataframe is the condition we want our final -->
<!-- dataframe to adhere to (e.g. village name is Chirodzo):  -->

<!-- ```{r, purl = FALSE} -->
<!-- # filters observations where village name is "Chirodzo"  -->
<!-- filter(interviews, village == "Chirodzo") -->
<!-- ``` -->

<!-- We can also specify multiple conditions within the `filter()` function. We can -->
<!-- combine conditions using either "and" or "or" statements. In an "and"  -->
<!-- statement, an observation (row) must meet **every** criteria to be included -->
<!-- in the resulting dataframe. To form "and" statements within dplyr, we can  pass -->
<!-- our desired conditions as arguments in the `filter()` function, separated by -->
<!-- commas: -->

<!-- ```{r, purl=FALSE} -->

<!-- # filters observations with "and" operator (comma) -->
<!-- # output dataframe satisfies ALL specified conditions -->
<!-- filter(interviews, village == "Chirodzo",  -->
<!--                    rooms > 1,  -->
<!--                    no_meals > 2) -->
<!-- ``` -->

<!-- We can also form "and" statements with the `&` operator instead of commas: -->

<!-- ```{r, purl=FALSE} -->
<!-- # filters observations with "&" logical operator -->
<!-- # output dataframe satisfies ALL specified conditions -->
<!-- filter(interviews, village == "Chirodzo" &  -->
<!--                    rooms > 1 &  -->
<!--                    no_meals > 2) -->
<!-- ``` -->

<!-- In an "or" statement, observations must meet *at least one* of the specified conditions.  -->
<!-- To form "or" statements we use the logical operator for "or," which is the vertical bar (|):  -->

<!-- ```{r, purl=FALSE} -->
<!-- # filters observations with "|" logical operator -->
<!-- # output dataframe satisfies AT LEAST ONE of the specified conditions -->
<!-- filter(interviews, village == "Chirodzo" | village == "Ruaca") -->
<!-- ``` -->


<!-- ## Pipes -->

<!-- What if you want to select and filter at the same time? There are three -->
<!-- ways to do this: use intermediate steps, nested functions, or pipes. -->

<!-- With intermediate steps, you create a temporary dataframe and use -->
<!-- that as input to the next function, like this: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews2 <- filter(interviews, village == "Chirodzo") -->
<!-- interviews_ch <- select(interviews2, village:respondent_wall_type) -->
<!-- ``` -->

<!-- This is readable, but can clutter up your workspace with lots of objects that -->
<!-- you have to name individually. With multiple steps, that can be hard to keep -->
<!-- track of. -->

<!-- You can also nest functions (i.e. one function inside of another), like this: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_ch <- select(filter(interviews, village == "Chirodzo"), -->
<!--                          village:respondent_wall_type) -->
<!-- ``` -->

<!-- This is handy, but can be difficult to read if too many functions are nested, as -->
<!-- R evaluates the expression from the inside out (in this case, filtering, then -->
<!-- selecting). -->

<!-- The last option, *pipes*, are a recent addition to R. Pipes let you take the -->
<!-- output of one function and send it directly to the next, which is useful when -->
<!-- you need to do many things to the same dataset. Pipes in R look like `%>%` and -->
<!-- are made available via the **`magrittr`** package, installed automatically with -->
<!-- **`dplyr`**. If you use RStudio, you can type the pipe with:   -->
<!-- - <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> if you have a PC or <kbd>Cmd</kbd> + -->
<!-- <kbd>Shift</kbd> + <kbd>M</kbd> if you have a Mac. -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(village == "Chirodzo") %>% -->
<!--     select(village:respondent_wall_type) -->
<!-- ``` -->

<!-- In the above code, we use the pipe to send the `interviews` dataset first -->
<!-- through `filter()` to keep rows where `village` is "Chirodzo", then through -->
<!-- `select()` to keep only the `no_membrs` and `years_liv` columns. Since `%>%` -->
<!-- takes the object on its left and passes it as the first argument to the function -->
<!-- on its right, we don't need to explicitly include the dataframe as an argument -->
<!-- to the `filter()` and `select()` functions any more. -->

<!-- Some may find it helpful to read the pipe like the word "then". For instance, -->
<!-- in the above example, we take the dataframe `interviews`, *then* we `filter` -->
<!-- for rows with `village == "Chirodzo"`, *then* we `select` columns `no_membrs` and -->
<!-- `years_liv`. The **`dplyr`** functions by themselves are somewhat simple, -->
<!-- but by combining them into linear workflows with the pipe, we can accomplish -->
<!-- more complex data wrangling operations. -->

<!-- If we want to create a new object with this smaller version of the data, we -->
<!-- can assign it a new name: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_ch <- interviews %>% -->
<!--     filter(village == "Chirodzo") %>% -->
<!--     select(village:respondent_wall_type) -->

<!-- interviews_ch -->

<!-- ``` -->

<!-- Note that the final dataframe (`interviews_ch`) is the leftmost part of this -->
<!-- expression. -->

<!-- > ## Exercise -->
<!-- > -->
<!-- >  Using pipes, subset the `interviews` data to include interviews -->
<!-- > where respondents were members of an irrigation association -->
<!-- > (`memb_assoc`) and retain only the columns `affect_conflicts`, -->
<!-- > `liv_count`, and `no_meals`. -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > interviews %>% -->
<!-- > >     filter(memb_assoc == "yes") %>% -->
<!-- > >     select(affect_conflicts, liv_count, no_meals) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- {: .challenge} -->

<!-- ### Mutate -->

<!-- Frequently you'll want to create new columns based on the values in existing -->
<!-- columns, for example to do unit conversions, or to find the ratio of values in -->
<!-- two columns. For this we'll use `mutate()`. -->

<!-- We might be interested in the ratio of number of household members -->
<!-- to rooms used for sleeping (i.e. avg number of people per room): -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     mutate(people_per_room = no_membrs / rooms) -->
<!-- ``` -->

<!-- We may be interested in investigating whether being a member of an -->
<!-- irrigation association had any effect on the ratio of household members -->
<!-- to rooms. To look at this relationship, we will first remove -->
<!-- data from our dataset where the respondent didn't answer the -->
<!-- question of whether they were a member of an irrigation association. -->
<!-- These cases are recorded as "NULL" in the dataset. -->

<!-- To remove these cases, we could insert a `filter()` in the chain: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(!is.na(memb_assoc)) %>% -->
<!--     mutate(people_per_room = no_membrs / rooms) -->
<!-- ``` -->

<!-- The `!` symbol negates the result of the `is.na()` function. Thus, if `is.na()` -->
<!-- returns a value of `TRUE` (because the `memb_assoc` is missing), the `!` symbol -->
<!-- negates this and says we only want values of `FALSE`, where `memb_assoc` **is -->
<!-- not** missing. -->

<!-- > ## Exercise -->
<!-- > -->
<!-- >  Create a new dataframe from the `interviews` data that meets the following -->
<!-- >  criteria: contains only the `village` column and a new column called -->
<!-- >  `total_meals` containing a value that is equal to the total number of meals -->
<!-- >  served in the household per day on average (`no_membrs` times `no_meals`). -->
<!-- >  Only the rows where `total_meals` is greater than 20 should be shown in the -->
<!-- >  final dataframe. -->
<!-- > -->
<!-- >  **Hint**: think about how the commands should be ordered to produce this data -->
<!-- >  frame! -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ``` {r} -->
<!-- > > interviews_total_meals <- interviews %>% -->
<!-- > >     mutate(total_meals = no_membrs * no_meals) %>% -->
<!-- > >     filter(total_meals > 20) %>% -->
<!-- > >     select(village, total_meals) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- {: .challenge} -->

<!-- ### Split-apply-combine data analysis and the summarize() function -->

<!-- Many data analysis tasks can be approached using the *split-apply-combine* -->
<!-- paradigm: split the data into groups, apply some analysis to each group, and -->
<!-- then combine the results. **`dplyr`** makes this very easy through the use of -->
<!-- the `group_by()` function. -->


<!-- #### The `summarize()` function -->

<!-- `group_by()` is often used together with `summarize()`, which collapses each -->
<!-- group into a single-row summary of that group.  `group_by()` takes as arguments -->
<!-- the column names that contain the **categorical** variables for which you want -->
<!-- to calculate the summary statistics. So to compute the average household size by -->
<!-- village: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     group_by(village) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs)) -->
<!-- ``` -->

<!-- You may also have noticed that the output from these calls doesn't run off the -->
<!-- screen anymore. It's one of the advantages of `tbl_df` over dataframe. -->

<!-- You can also group by multiple columns: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs)) -->
<!-- ``` -->

<!-- Note that the output is a grouped tibble. To obtain an ungrouped tibble, use the -->
<!-- `ungroup` function: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs)) %>% -->
<!--     ungroup() -->
<!-- ``` -->

<!-- When grouping both by `village` and `membr_assoc`, we see rows in our table for -->
<!-- respondents who did not specify whether they were a member of an irrigation -->
<!-- association. We can exclude those data from our table using a filter step. -->


<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(!is.na(memb_assoc)) %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs)) -->
<!-- ``` -->

<!-- Once the data are grouped, you can also summarize multiple variables at the same -->
<!-- time (and not necessarily on the same variable). For instance, we could add a -->
<!-- column indicating the minimum household size for each village for each group -->
<!-- (members of an irrigation association vs not): -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(!is.na(memb_assoc)) %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs), -->
<!--               min_membrs = min(no_membrs)) -->
<!-- ``` -->

<!-- It is sometimes useful to rearrange the result of a query to inspect the values. -->
<!-- For instance, we can sort on `min_membrs` to put the group with the smallest -->
<!-- household first: -->


<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(!is.na(memb_assoc)) %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs), -->
<!--               min_membrs = min(no_membrs)) %>% -->
<!--     arrange(min_membrs) -->
<!-- ``` -->

<!-- To sort in descending order, we need to add the `desc()` function. If we want to -->
<!-- sort the results by decreasing order of minimum household size: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     filter(!is.na(memb_assoc)) %>% -->
<!--     group_by(village, memb_assoc) %>% -->
<!--     summarize(mean_no_membrs = mean(no_membrs), -->
<!--               min_membrs = min(no_membrs)) %>% -->
<!--     arrange(desc(min_membrs)) -->
<!-- ``` -->

<!-- #### Counting -->

<!-- When working with data, we often want to know the number of observations found -->
<!-- for each factor or combination of factors. For this task, **`dplyr`** provides -->
<!-- `count()`. For example, if we wanted to count the number of rows of data for -->
<!-- each village, we would do: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     count(village) -->
<!-- ``` -->

<!-- For convenience, `count()` provides the `sort` argument to get results in -->
<!-- decreasing order: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--     count(village, sort = TRUE) -->
<!-- ``` -->

<!-- > ## Exercise -->
<!-- > -->
<!-- > How many households in the survey have an average of -->
<!-- > two meals per day? Three meals per day? Are there any other numbers -->
<!-- > of meals represented? -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > interviews %>% -->
<!-- > >    count(no_meals) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- > -->
<!-- > Use `group_by()` and `summarize()` to find the mean, min, and max -->
<!-- > number of household members for each village. Also add the number of -->
<!-- > observations (hint: see `?n`). -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > interviews %>% -->
<!-- > >   group_by(village) %>% -->
<!-- > >   summarize( -->
<!-- > >       mean_no_membrs = mean(no_membrs), -->
<!-- > >       min_no_membrs = min(no_membrs), -->
<!-- > >       max_no_membrs = max(no_membrs), -->
<!-- > >       n = n() -->
<!-- > >   ) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- > -->
<!-- > What was the largest household interviewed in each month? -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > # if not already included, add month, year, and day columns -->
<!-- > > library(lubridate) # load lubridate if not already loaded -->
<!-- > > interviews %>% -->
<!-- > >     mutate(month = month(interview_date), -->
<!-- > >            day = day(interview_date), -->
<!-- > >            year = year(interview_date)) %>% -->
<!-- > >     group_by(year, month) %>% -->
<!-- > >     summarize(max_no_membrs = max(no_membrs)) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- {: .challenge} -->

<!-- ## Reshaping with pivot_wider() and pivot_longer() -->

<!-- There are essentially three rules that define a "tidy" dataset: -->

<!-- 1. Each variable has its own column -->
<!-- 2. Each observation has its own row -->
<!-- 3. Each value must have its own cell -->

<!-- In this section we will explore how these rules are linked to the different -->
<!-- data formats researchers are often interested in: "wide" and "long". This -->
<!-- tutorial will help you efficiently transform your data shape regardless of -->
<!-- original format. First we will explore qualities of the `interviews` data and -->
<!-- how they relate to these different types of data formats. -->

<!-- ### Long and wide data formats -->

<!-- In the `interviews` data, each row contains the values of variables associated -->
<!-- with each record collected (each interview in the villages), where it is stated -->
<!-- that the the `key_ID` was "added to provide a unique Id for each observation" -->
<!-- and the `instance_ID` "does this as well but it is not as convenient to use." -->

<!-- However, with some inspection, we notice that there are more than one row in the -->
<!-- dataset with the same `key_ID` (as seen below). However, the `instanceID`s -->
<!-- associated with these duplicate `key_ID`s are not the same. Thus, we should -->
<!-- think of `instanceID` as the unique identifier for observations! -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--   select(key_ID, village, interview_date, instanceID) -->
<!-- ``` -->

<!-- As seen in the code below, for each interview date in each village no -->
<!-- `instanceID`s are the same. Thus, this format is what is called a "long" data -->
<!-- format, where each observation occupies only one row in the dataframe. -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews %>% -->
<!--   filter(village == "Chirodzo") %>% -->
<!--   select(key_ID, village, interview_date, instanceID) %>% -->
<!--   sample_n(size = 10) -->
<!-- ``` -->

<!-- We notice that the layout or format of the `interviews` data is in a format that -->
<!-- adheres to rules 1-3, where -->

<!-- - each column is a variable -->
<!-- - each row is an observation -->
<!-- - each value has its own cell -->

<!-- This is called a "long" data format. But, we notice that each column represents -->
<!-- a different variable. In the "longest" data format there would only be three -->
<!-- columns, one for the id variable, one for the observed variable, and one for the -->
<!-- observed value (of that variable). This data format is quite unsightly -->
<!-- and difficult to work with, so you will rarely see it in use. -->

<!-- Alternatively, in a "wide" data format we see modifications to rule 1, where -->
<!-- each column no longer represents a single variable. Instead, columns can -->
<!-- represent different levels/values of a variable. For instance, in some data you -->
<!-- encounter the researchers may have chosen for every survey date to be a -->
<!-- different column. -->

<!-- These may sound like dramatically different data layouts, but there are some -->
<!-- tools that make transitions between these layouts much simpler than you might -->
<!-- think! The gif below shows how these two formats relate to each other, and -->
<!-- gives you an idea of how we can use R to shift from one format to the other. -->

<!-- ![](../fig/tidyr-pivot_wider_longer.gif) -->
<!-- Long and wide dataframe layouts mainly affect readability. You may find that -->
<!-- visually you may prefer the "wide" format, since you can see more of the data on -->
<!-- the screen. However, all of the R functions we have used thus far expect for -->
<!-- your data to be in a "long" data format. This is because the long format is more -->
<!-- machine readable and is closer to the formatting of databases. -->

<!-- ### Questions which warrant different data formats -->

<!-- In interviews, each row contains the values of variables associated with each -->
<!-- record (the unit), values such as the village of the respondent, the number -->
<!-- of household members, or the type of wall their house had. This format allows -->
<!-- for us to make comparisons across individual surveys, but what if we wanted to -->
<!-- look at differences in households grouped by different types of housing -->
<!-- construction materials? -->

<!-- To facilitate this comparison we would need to create a new table where each row -->
<!-- (the unit) was comprised of values of variables associated with housing material -->
<!-- (e.g. the `respondent_wall_type`). In practical terms this means the values of -->
<!-- the wall construction materials in `respondent_wall_type` (e.g. muddaub, -->
<!-- burntbricks, cement, sunbricks) would become the names of column variables and -->
<!-- the cells would contain values of `TRUE` or `FALSE`, for whether that house had -->
<!-- a wall made of that material. -->

<!-- Once we we've created this new table, we can explore the relationship within and -->
<!-- between villages. The key point here is that we are still following a tidy data -->
<!-- structure, but we have **reshaped** the data according to the observations of -->
<!-- interest. -->

<!-- Alternatively, if the interview dates were spread across multiple columns, and -->
<!-- we were interested in visualizing, within each village, how irrigation -->
<!-- conflicts have changed over time. This would require for the interview date to -->
<!-- be included in a single column rather than spread across multiple columns. Thus, -->
<!-- we would need to transform the column names into values of a variable. -->

<!-- We can do both these of transformations with two `tidyr` functions, -->
<!-- `pivot_wider()` and `pivot_longer()`. -->

<!-- ### Pivoting wider -->

<!-- `pivot_wider()` takes three principal arguments: -->

<!-- 1. the data -->
<!-- 2. the *names_from* column variable whose values will become new column names. -->
<!-- 3. the *values_from* column variable whose values will fill the new column -->
<!--    variables. -->

<!-- Further arguments include `values_fill` which, if set, fills in missing values -->
<!-- with the value provided. -->

<!-- Let's use `pivot_wider()` to transform interviews to create new columns for each -->
<!-- type of wall construction material. We will make use of the pipe operator as -->
<!-- have done before. Because both the `names_from` and `values_from` parameters -->
<!-- must come from column values, we will create a dummy column (we'll name it -->
<!-- `wall_type_logical`) to hold the value `TRUE`, which we will then place into the -->
<!-- appropriate column that corresponds to the wall construction material for that -->
<!-- respondent. When using `mutate()` if you give a single value, it will be used -->
<!-- for all observations in the dataset. -->

<!-- For each row in our newly pivoted table, only one of the newly created wall type -->
<!-- columns will have a value of `TRUE`, since each house can only be made of one -->
<!-- wall type. The default value that `pivot_wider` uses to fill the other wall -->
<!-- types is `NA`. -->

<!-- ![](../fig/pivot_long_to_wide.png) -->

<!-- If instead of the default value being `NA`, we wanted these values to be `FALSE`, -->
<!-- we can insert a default value into the `values_fill` argument. By including -->
<!-- `values_fill = list(wall_type_logical = FALSE)` inside `pivot_wider()`, we can -->
<!-- fill the remainder of the wall type columns for that row with the value `FALSE`. -->


<!-- ```{r, purl = FALSE} -->
<!-- interviews_wide <- interviews %>% -->
<!--     mutate(wall_type_logical = TRUE) %>% -->
<!--     pivot_wider(names_from = respondent_wall_type, -->
<!--                 values_from = wall_type_logical, -->
<!--                 values_fill = list(wall_type_logical = FALSE)) -->
<!-- ``` -->


<!-- View the `interviews_wide` dataframe and notice that there is no longer a -->
<!-- column titled `respondent_wall_type`. This is because there is a default -->
<!-- parameter in `pivot_wider()` that drops the original column. The values that -->
<!-- were in that column have now become columns named `muddaub`, `burntbricks`, -->
<!-- `sunbricks`, and `cement`. You can use `dim(interviews)` and -->
<!-- `dim(interviews_wide)` to see how the number of columns has changed between -->
<!-- the two datasets. -->

<!-- ### Pivoting longer -->

<!-- The opposing situation could occur if we had been provided with data in the form -->
<!-- of `interviews_wide`, where the building materials are column names, but we -->
<!-- wish to treat them as values of a `respondent_wall_type` variable instead. -->

<!-- In this situation we are gathering these columns turning them into a pair -->
<!-- of new variables. One variable includes the column names as values, and the -->
<!-- other variable contains the values in each cell previously associated with the -->
<!-- column names. We will do this in two steps to make this process a bit clearer. -->

<!-- `pivot_longer()` takes four principal arguments: -->

<!-- 1. the data -->
<!-- 2. *cols* are the names of the columns we use to fill the a new values variable -->
<!--    (or to drop). -->
<!-- 3. the *names_to* column variable we wish to create from the *cols* provided. -->
<!-- 4. the *values_to* column variable we wish to create and fill with values -->
<!-- associated with the *cols* provided. -->

<!-- To recreate our original dataframe, we will use the following: -->

<!-- 1. the data - `interviews_wide` -->
<!-- 2. a list of *cols* (columns) that are to be reshaped; these can be specified -->
<!--    using a  `:` if the columns to be reshaped are in one area of the dataframe, -->
<!--    or with a vector (`c()`) command if the columns are spread throughout the -->
<!--    dataframe. -->
<!-- 3. the *names_to* column will be a character string of the name the column -->
<!--    these columns will be collapsed into ("respondent_wall_type"). -->
<!-- 4. the *values_to* column will be a character string of the name of the -->
<!--    column the values of the collapsed columns will be inserted into -->
<!--    ("wall_type_logical"). This column will be populated with values of -->
<!--    `TRUE` or `FALSE`. -->


<!-- ```{r, purl = FALSE} -->
<!-- interviews_long <- interviews_wide %>% -->
<!--     pivot_longer(cols = burntbricks:sunbricks, -->
<!--                  names_to = "respondent_wall_type", -->
<!--                  values_to = "wall_type_logical") -->
<!-- ``` -->


<!-- ![](../fig/pivot_wide_to_long.png) -->

<!-- This creates a dataframe with  rows (4 rows per -->
<!-- interview respondent). The four rows for each respondent differ only in the -->
<!-- value of the "respondent_wall_type" and "wall_type_logical" columns. View the -->
<!-- data to see what this looks like. -->

<!-- Only one row for each interview respondent is informative--we know that if the -->
<!-- house walls are made of "sunbrick" they aren't made of any other the other -->
<!-- materials. Therefore, it would make sense to filter our dataset to only keep -->
<!-- values where `wall_type_logical` is `TRUE`. Because `wall_type_logical` is -->
<!-- already either `TRUE` or `FALSE`, when passing the column name to `filter()`, -->
<!-- it will automatically already only keep rows where this column has the value -->
<!-- `TRUE`. We can then remove the `wall_type_logical` column. -->

<!-- We do all of these steps together in the next chunk of code: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_long <- interviews_wide %>% -->
<!--     pivot_longer(cols = c(burntbricks, cement, muddaub, sunbricks), -->
<!--                  names_to = "respondent_wall_type", -->
<!--                  values_to = "wall_type_logical") %>% -->
<!--     filter(wall_type_logical) %>% -->
<!--     select(-wall_type_logical) -->
<!-- ``` -->

<!-- View both `interviews_long` and `interviews_wide` and compare their structure. -->

<!-- ## Applying `pivot_wider()` to clean our data -->

<!-- Now that we've learned about `pivot_longer()` and `pivot_wider()` we're going to -->
<!-- put these functions to use to fix a problem with the way that our data is -->
<!-- structured. In the spreadsheets lesson, we learned that it's best practice to -->
<!-- have only a single piece of information in each cell of your spreadsheet. In -->
<!-- this dataset, we have several columns which contain multiple pieces of -->
<!-- information. For example, the `items_owned` column contains information about -->
<!-- whether our respondents owned a fridge, a television, etc. To make this data -->
<!-- easier to analyze, we will split this column and create a new column for each -->
<!-- item. Each cell in that column will either be `TRUE` or `FALSE` and will -->
<!-- indicate whether that interview respondent owned that item (similar to what -->
<!-- we did previously with `wall_type`). -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_items_owned <- interviews %>% -->
<!--   separate_rows(items_owned, sep = ";") %>% -->
<!--   replace_na(list(items_owned = "no_listed_items")) %>% -->
<!--   mutate(items_owned_logical = TRUE) %>% -->
<!--     pivot_wider(names_from = items_owned, -->
<!--                 values_from = items_owned_logical, -->
<!--                 values_fill = list(items_owned_logical = FALSE)) -->

<!-- nrow(interviews_items_owned) -->
<!-- ``` -->

<!-- There are a couple of new concepts in this code chunk, so let's walk through it -->
<!-- line by line. First we create a new object (`interviews_items_owned`) based on -->
<!-- the `interviews` dataframe. -->

<!-- ```{r, eval = FALSE} -->
<!-- interviews_items_owned <- interviews %>% -->
<!-- ``` -->

<!-- Then we use the new function `separate_rows()` from the **`tidyr`** package to -->
<!-- separate the values of `items_owned` based on the presence of semi-colons (`;`). -->
<!-- The values of this variable were multiple items separated by semi-colons, so -->
<!-- this action creates a row for each item listed in a household's possession. -->
<!-- Thus, we end up with a long format version of the dataset, with multiple rows -->
<!-- for each respondent. For example, if a respondent has a television and a solar -->
<!-- panel, that respondent will now have two rows, one with "television" and the -->
<!-- other with "solar panel" in the `items_owned` column. -->

<!-- ```{r, eval = FALSE} -->
<!-- separate_rows(items_owned, sep = ";") %>% -->
<!-- ``` -->

<!-- You may notice that one of the columns is called `´NA´`. This is because some -->
<!-- of the respondents did not own any of the items that was in the interviewer's -->
<!-- list. We can use the `replace_na()` function to change these `NA` values to -->
<!-- something more meaningful. The `replace_na()` function expects for you to give -->
<!-- it a `list()` of columns that you would like to replace the `NA` values in, -->
<!-- and the value that you would like to replace the `NA`s. This ends up looking -->
<!-- like this: -->

<!-- ```{r, eval = FALSE} -->
<!-- replace_na(list(items_owned = "no_listed_items")) %>% -->
<!-- ``` -->

<!-- Next, we create a new variable named `items_owned_logical`, which has one value -->
<!-- (`TRUE`) for every row. This makes sense, since each item in every row was owned -->
<!-- by that household. We are constructing this variable so that when spread the -->
<!-- `items_owned` across multiple columns, we can fill the values of those columns -->
<!-- with logical values describing whether the household did (`TRUE`) or didn't -->
<!-- (`FALSE`) own that particular item.   -->

<!-- ```{r, eval = FALSE} -->
<!-- mutate(items_owned_logical = TRUE) %>% -->
<!-- ``` -->

<!-- Lastly, we use `pivot_wider()` to switch from long format to wide format. This -->
<!-- creates a new column for each of the unique values in the `items_owned` column, -->
<!-- and fills those columns with the values of `items_owned_logical`. We also -->
<!-- declare that for items that are missing, we want to fill those cells with the -->
<!-- value of `FALSE` instead of `NA`. -->

<!-- ```{r, eval = FALSE} -->
<!-- pivot_wider(names_from = items_owned, -->
<!--             values_from = items_owned_logical, -->
<!--             values_fill = list(items_owned_logical = FALSE)) -->

<!-- ``` -->

<!-- View the `interviews_items_owned` dataframe. It should have -->
<!-- 131 rows (the same number of rows you had originally), but -->
<!-- extra columns for each item. How many columns were added? -->

<!-- This format of the data allows us to do interesting things, like make a table -->
<!-- showing the number of respondents in each village who owned a particular item: -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_items_owned %>% -->
<!--   filter(bicycle) %>% -->
<!--   group_by(village) %>% -->
<!--   count(bicycle) -->
<!-- ``` -->

<!-- Or below we calculate the average number of items from the list owned by -->
<!-- respondents in each village. This code uses the `rowSums()` function to count -->
<!-- the number of `TRUE` values in the `bicycle` to `car` columns for each row, -->
<!-- hence its name. We then group the data by villages and caluculate the mean -->
<!-- number of items, so each average is grouped by village. -->

<!-- ```{r, purl = FALSE} -->
<!-- interviews_items_owned %>% -->
<!--     mutate(number_items = rowSums(select(., bicycle:car))) %>% -->
<!--     group_by(village) %>% -->
<!--     summarize(mean_items = mean(number_items)) -->
<!-- ``` -->

<!-- > ## Exercise -->
<!-- > -->
<!-- > 1. Create a new dataframe (named `interviews_months_lack_food`) that has one -->
<!-- > column for each month and records `TRUE` or `FALSE` for whether each interview -->
<!-- > respondent was lacking food in that month. -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > interviews_months_lack_food <- interviews %>% -->
<!-- > >   separate_rows(months_lack_food, sep = ";") %>% -->
<!-- > >   mutate(months_lack_food_logical  = TRUE) %>% -->
<!-- > >   pivot_wider(names_from = months_lack_food, -->
<!-- > >               values_from = months_lack_food_logical, -->
<!-- > >               values_fill = list(months_lack_food_logical = FALSE)) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- > -->
<!-- > 2. How many months (on average) were respondents without food if -->
<!-- > they did belong to an irrigation association? What about if they didn't? -->
<!-- > -->
<!-- > > ## Solution -->
<!-- > > -->
<!-- > > ```{r} -->
<!-- > > interviews_months_lack_food %>% -->
<!-- > >   mutate(number_months = rowSums(select(., Jan:May))) %>% -->
<!-- > >   group_by(memb_assoc) %>% -->
<!-- > >   summarize(mean_months = mean(number_months)) -->
<!-- > > ``` -->
<!-- > {: .solution} -->
<!-- {: .challenge} -->

<!-- ## Exporting data -->

<!-- Now that you have learned how to use **`dplyr`** to extract information from -->
<!-- or summarize your raw data, you may want to export these new data sets to share -->
<!-- them with your collaborators or for archival. -->

<!-- Similar to the `read_csv()` function used for reading CSV files into R, there is -->
<!-- a `write_csv()` function that generates CSV files from dataframes. -->

<!-- Before using `write_csv()`, we are going to create a new folder, `data_output`, -->
<!-- in our working directory that will store this generated dataset. We don't want -->
<!-- to write generated datasets in the same directory as our raw data. It's good -->
<!-- practice to keep them separate. The `data` folder should only contain the raw, -->
<!-- unaltered data, and should be left alone to make sure we don't delete or modify -->
<!-- it. In contrast, our script will generate the contents of the `data_output` -->
<!-- directory, so even if the files it contains are deleted, we can always -->
<!-- re-generate them. -->

<!-- In preparation for our next lesson on plotting, we are going to create a version -->
<!-- of the dataset where each of the columns includes only one data value. To do -->
<!-- this, we will use `pivot_wider` to expand the `months_lack_food` and -->
<!-- `items_owned` columns. We will also create a couple of summary columns. -->


<!-- ```{r, purl = FALSE} -->
<!-- interviews_plotting <- interviews %>% -->
<!--   ## pivot wider by items_owned -->
<!--   separate_rows(items_owned, sep = ";") %>% -->
<!--   ## if there were no items listed, changing NA to no_listed_items -->
<!--   replace_na(list(items_owned = "no_listed_items")) %>% -->
<!--   mutate(items_owned_logical = TRUE) %>% -->
<!--   pivot_wider(names_from = items_owned, -->
<!--               values_from = items_owned_logical, -->
<!--               values_fill = list(items_owned_logical = FALSE)) %>% -->
<!--   ## pivot wider by months_lack_food -->
<!--   separate_rows(months_lack_food, sep = ";") %>% -->
<!--   mutate(months_lack_food_logical = TRUE) %>% -->
<!--   pivot_wider(names_from = months_lack_food, -->
<!--               values_from = months_lack_food_logical, -->
<!--               values_fill = list(months_lack_food_logical = FALSE)) %>% -->
<!--   ## add some summary columns -->
<!--   mutate(number_months_lack_food = rowSums(select(., Jan:May))) %>% -->
<!--   mutate(number_items = rowSums(select(., bicycle:car))) -->
<!-- ``` -->

<!-- Now we can save this dataframe to our `data_output` directory. -->

<!-- ```{r, purl = FALSE, eval = FALSE} -->
<!-- write_csv (interviews_plotting, file = "data_output/interviews_plotting.csv") -->
<!-- ``` -->

<!-- ```{r, purl = FALSE, eval = TRUE, echo = FALSE} -->
<!-- if (!dir.exists("data_output")) dir.create("data_output") -->
<!-- write_csv(interviews_plotting, "data_output/interviews_plotting.csv") -->
<!-- ``` -->


{% include links.md %}
