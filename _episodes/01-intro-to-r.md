---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-intro-to-r.md in _episodes_rmd/
title: "Introduction to R"
teaching: 50
exercises: 30
questions:
- "What data types are available in R?"
- "What is an object?"
- "How can values be initially assigned to variables of different data types?"
- "What arithmetic and logical operators can be used?"
- "How can subsets be extracted from vectors?"
- "How does R treat missing values?"
- "How can we deal with missing values in R?"
objectives: 
- "A quick recap of the following concepts:"
- "Define the following terms as they relate to R: object, assign, call, function, arguments, options."
- "Assign values to objects in R."
- "Learn how to name objects."
- "Use comments to inform script."
- "Solve simple arithmetic operations in R."
- "Call functions and use arguments to change their default options."
- "Inspect the content of vectors and manipulate their content."
- "Subset and extract values from vectors."
- "Analyze vectors with missing data."
source: Rmd
---




## A very short refresher on R

You can get output from R simply by typing math in the console:


~~~
3 + 5
~~~
{: .language-r}



~~~
[1] 8
~~~
{: .output}



~~~
12 / 7
~~~
{: .language-r}



~~~
[1] 1.714286
~~~
{: .output}

We can assign values to variables:


~~~
area_hectares <- 1.0
~~~
{: .language-r}

`<-` is the assignment operator. It assigns values on the right to objects on
the left. So, after executing `x <- 3`, the value of `x` is `3`. The arrow can
be read as 3 **goes into** `x`.  


Now that R has `area_hectares` in memory, we can do arithmetic with it. For
instance, we may want to convert this area into acres (area in acres is 2.47 times the area in hectares):


~~~
2.47 * area_hectares
~~~
{: .language-r}



~~~
[1] 2.47
~~~
{: .output}

We can also change an object's value by assigning it a new one:


~~~
area_hectares <- 2.5
2.47 * area_hectares
~~~
{: .language-r}



~~~
[1] 6.175
~~~
{: .output}


## Comments

All programming languages allow the programmer to include comments in their code. To do this in R we use the `#` character.
Anything to the right of the `#` sign and up to the end of the line is treated as a comment and is ignored by R. You can start lines with comments
or include them after any code on the line.


~~~
area_hectares <- 1.0			# land area in hectares
area_acres <- area_hectares * 2.47	# convert to acres
area_acres				# print land area in acres.
~~~
{: .language-r}



~~~
[1] 2.47
~~~
{: .output}


### Functions and their arguments

Functions are "canned scripts" that automate more complicated sets of commands
including operations assignments, etc. Many functions are predefined, or can be
made available by importing R *packages* (more on that later). A function
usually gets one or more inputs called *arguments*. Functions often (but not
always) return a *value*. A typical example would be the function `sqrt()`. The
input (the argument) must be a number, and the return value (in fact, the
output) is the square root of that number. Executing a function ('running it')
is called *calling* the function. An example of a function call is:


~~~
b <- sqrt(a)
~~~
{: .language-r}

Let's try a function that can take multiple arguments: `round()`.


~~~
round(3.14159)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}


Here, we've called `round()` with just one argument, `3.14159`, and it has
returned the value `3`. 

We can get information on how a function works, with the help function:


~~~
?round
~~~
{: .language-r}

We see that if we want a different number of digits, we can
type `digits=2` or however many we want.


~~~
round(3.14159, digits = 2)
~~~
{: .language-r}



~~~
[1] 3.14
~~~
{: .output}



## Vectors and data types


A vector is the most common and basic data type in R, and is pretty much
the workhorse of R. A vector is composed by a series of values, which can be
either numbers or characters. We can assign a series of values to a vector using
the `c()` function. For example we can create a vector of the number of household
members for the households we've interviewed and assign
it to a new object `hh_members`:


~~~
hh_members <- c(3, 7, 10, 6)
hh_members
~~~
{: .language-r}



~~~
[1]  3  7 10  6
~~~
{: .output}

A vector can also contain characters. For example, we can have
a vector of the building material used to construct our
interview respondents' walls (`respondent_wall_type`):


~~~
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type
~~~
{: .language-r}



~~~
[1] "muddaub"     "burntbricks" "sunbricks"  
~~~
{: .output}

The quotes around "muddaub", etc. are essential here. Without the quotes R
will assume there are objects called `muddaub`, `burntbricks` and `sunbricks`. As these objects
don't exist in R's memory, there will be an error message.

There are many functions that allow you to inspect the content of a
vector. `length()` tells you how many elements are in a particular vector:


~~~
length(hh_members)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}



~~~
length(respondent_wall_type)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}

An important feature of a vector, is that all of the elements are the same type of data.
The function `class()` indicates the class (the type of element) of an object:


~~~
class(hh_members)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
class(respondent_wall_type)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

The function `str()` provides an overview of the structure of an object and its
elements. It is a useful function when working with large and complex
objects:


~~~
str(hh_members)
~~~
{: .language-r}



~~~
 num [1:4] 3 7 10 6
~~~
{: .output}



~~~
str(respondent_wall_type)
~~~
{: .language-r}



~~~
 chr [1:3] "muddaub" "burntbricks" "sunbricks"
~~~
{: .output}

You can use the `c()` function to add other elements to your vector:

~~~
possessions <- c("bicycle", "radio", "television")
possessions <- c("car", possessions) # add to the beginning of the vector
possessions
~~~
{: .language-r}



~~~
[1] "car"        "bicycle"    "radio"      "television"
~~~
{: .output}

In the first line, we take the original vector `possessions`,
add the value `"mobile_phone"` to the end of it, and save the result back into
`possessions`. Then we add the value `"car"` to the beginning, again saving the result
back into `possessions`.

We can do this over and over again to grow a vector, or assemble a dataset.
As we program, this may be useful to add results that we are collecting or
calculating.


Vectors are one of the many **data structures** that R uses. Other important
ones are lists (`list`), matrices (`matrix`), data frames (`data.frame`),
factors (`factor`) and arrays (`array`).



## Subsetting vectors

If we want to extract one or several values from a vector, we must provide one
or several indices in square brackets. For instance:


~~~
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type[2]
~~~
{: .language-r}



~~~
[1] "burntbricks"
~~~
{: .output}



~~~
respondent_wall_type[c(3, 2)]
~~~
{: .language-r}



~~~
[1] "sunbricks"   "burntbricks"
~~~
{: .output}

We can also repeat the indices to create an object with more elements than the
original one:


~~~
more_respondent_wall_type <- respondent_wall_type[c(1, 2, 3, 2, 1, 3)]
more_respondent_wall_type
~~~
{: .language-r}



~~~
[1] "muddaub"     "burntbricks" "sunbricks"   "burntbricks" "muddaub"    
[6] "sunbricks"  
~~~
{: .output}

R indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R
start counting at 1, because that's what human beings typically do. Languages in
the C family (including C++, Java, Perl, and Python) count from 0 because that's
simpler for computers to do.

### Conditional subsetting

Another common way of subsetting is by using a logical vector. `TRUE` will
select the element with the same index, while `FALSE` will not:


~~~
hh_members <- c(3, 7, 10, 6)
hh_members[c(TRUE, FALSE, TRUE, TRUE)]
~~~
{: .language-r}



~~~
[1]  3 10  6
~~~
{: .output}

Typically, these logical vectors are not typed by hand, but are the output of
other functions or logical tests. For instance, if you wanted to select only the
values above 5:


~~~
hh_members > 5    # will return logicals with TRUE for the indices that meet the condition
~~~
{: .language-r}



~~~
[1] FALSE  TRUE  TRUE  TRUE
~~~
{: .output}



~~~
## so we can use this to select only the values above 5
hh_members[hh_members > 5]
~~~
{: .language-r}



~~~
[1]  7 10  6
~~~
{: .output}

You can combine multiple tests using `&` (both conditions are true, AND) or `|`
(at least one of the conditions is true, OR):


~~~
hh_members[hh_members < 4 | hh_members > 7]
~~~
{: .language-r}



~~~
[1]  3 10
~~~
{: .output}



~~~
hh_members[hh_members >= 4 & hh_members <= 7]
~~~
{: .language-r}



~~~
[1] 7 6
~~~
{: .output}

Here, `<` stands for "less than", `>` for "greater than", `>=` for "greater than
or equal to", and `==` for "equal to". The double equal sign `==` is a test for
numerical equality between the left and right hand sides, and should not be
confused with the single `=` sign, which performs variable assignment (similar
to `<-`).

A common task is to search for certain strings in a vector.  One could use the
"or" operator `|` to test for equality to multiple values, but this can quickly
become tedious. 


~~~
possessions <- c("car", "bicycle", "radio", "television", "mobile_phone")
possessions[possessions == "car" | possessions == "bicycle"] # returns both car and bicycle
~~~
{: .language-r}



~~~
[1] "car"     "bicycle"
~~~
{: .output}

The function `%in%` allows you to test if any of the elements of a search vector
(on the left hand side) are found in the target vector (on the right hand side):


~~~
possessions %in% c("car", "bicycle")
~~~
{: .language-r}



~~~
[1]  TRUE  TRUE FALSE FALSE FALSE
~~~
{: .output}

Note that the output is the same length as the search vector on the left hand
side, because `%in%` checks whether each element of the search vector is found
somewhere in the target vector. Thus, you can use `%in%` to select the elements
in the search vector that appear in your target vector:


~~~
possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")
~~~
{: .language-r}



~~~
[1]  TRUE  TRUE FALSE FALSE FALSE
~~~
{: .output}



~~~
possessions[possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")]
~~~
{: .language-r}



~~~
[1] "car"     "bicycle"
~~~
{: .output}


## Missing data

As R was designed to analyze datasets, it includes the concept of missing data
(which is uncommon in other programming languages). Missing data are represented
in vectors as `NA`.

When doing operations on numbers, most functions will return `NA` if the data
you are working with include missing values. This feature
makes it harder to overlook the cases where you are dealing with missing data.
You can add the argument `na.rm=TRUE` to calculate the result while ignoring
the missing values.


~~~
rooms <- c(2, 1, 1, NA, 7)
mean(rooms)
~~~
{: .language-r}



~~~
[1] NA
~~~
{: .output}



~~~
max(rooms)
~~~
{: .language-r}



~~~
[1] NA
~~~
{: .output}



~~~
mean(rooms, na.rm = TRUE)
~~~
{: .language-r}



~~~
[1] 2.75
~~~
{: .output}



~~~
max(rooms, na.rm = TRUE)
~~~
{: .language-r}



~~~
[1] 7
~~~
{: .output}

If your data include missing values, you may want to become familiar with the
functions `is.na()`, `na.omit()`, and `complete.cases()`. See below for
examples.



Recall that you can use the `typeof()` function to find the type of your atomic vector.

{% include links.md %}
