---
title: "What is an API?"
teaching: 30
exercises: 15
output: 
  html_document:
    df_print: paged
objectives:
- Create a .Rmd document containing R code, text, and plots
- Create a YAML header to control output
- Understand basic syntax of (R)Markdown
- Customise code chunks to control formatting
- Use code chunks and in-line code to create dynamic, reproducible documents
keypoints: 
- R Markdown is a useful language for creating reproducible documents combining text and executable R-code.
- Specify chunk options to control formatting of the output document
source: Rmd
questions:
- What is R Markdown?
- How can I integrate my R code with text and plots?
- How can I convert .Rmd files to .html?
---

```{r setup, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("06-")
source("../bin/download_data.R")
```

## What is an API?

An API is an Application Programming Interface. It is a way of making 
applications, in our case an R-script, able to communicate with another 
application, here the Statistics Denmark databases.

Talking about APIs, we talk about several different things. It can be quite 
confusing, but dont worry!

What we want to be able to do, is to let our own application, our R-script,
send a command to a remote application, the databases of Statistics Denmark, 
in order to retrieve specific data.

An API defines the different commands we can send, and how the data that we 
get back, is formatted.

Often APIs will require a user account with a login and a password. 
Statistics Denmark does not.

The standard way to send a command, or a request, to an API is to use the 
GET (and POST) functions at the core of the internet. 

In a certain sense this is what we do when we access a website. We go to 
www.dr.dk/sporten and get a result, the current webpage at the front of 
the sports section of Danmarks Radio. 

If we instead ask www.dr.dk to return the result of our request for 
www.dr.dk/nyheder/politik, we will get the current webpage with news on politics.

This is what we do when we access an API. But instead of using our browser, we
use the method our browser uses (GET), tells that method that we would like 
some specified information, and get a result that is not a webpage, but rather
a set of data. Hopefully organised in a way that is easy to read.

Writing our own GET-requests to communicate with an API is not simple. 
Thankfully kind people have written libraries, some in R, that makes accessing 
specific APIs easier. The one we are going to use here is called "danstat"

## The danstat package/library


Before doing anything else, it is useful to take a look at the result:
```{r echo = F}
library(danstat)
variables <- list(list(code = "ieland", values = c(5100, 5128)),
                  list(code = "køn", values = c(1,2)),
                  list(code = "tid", values = NA))

data <- get_data("folk1c", variables)
data %>% head
```

This is from the table "folk1c" from Statistics Denmark.
We get some variables, IELAND, KØN, and TID. And then the content of the table, 
INDHOLD. Ie the number of men, living in denmark i the first quarter of 2008 in
the first line.

How do we get that table?

All tables from Statistics Denmark are organised in a hierarcical tree of 
subjects. 

Let us begin there.

Before using the library, we need to install it:

```{r eval=F}
install.packages("danstat")
```

After installation, we load the library using the library function. And then 
we can access the functions included in the library:

```{r}
library(danstat)
subjects <- get_subjects()
subjects
```

We get the 13 major subjects from Statistics Denmark. Each of them have sub-subjects.

Let us try to get the sub-subjects from the subject 02 - containing information
about populations and elections:

```{r}
sub_subjects <- get_subjects(subjects = "02")
sub_subjects
```



Statistics Denmark give access to 13 collections of data, organised in 
subjects. 

The get_subjects() function sends a request to the Statistics Denmark API, asking
for a list of the subjects. The information is returned to our script, and the
get_subjects() function presents us with a dataframe containing the information.

Each subject have sub-subjects. If we want to take a closer look at the 
subdivisions of a given subject, we use the get_subjects() function again,
this time specifying which subject we are interested in:

```{r}
subject <- get_subjects("02")
subject
```

The result is a bit complicated. The column "subjects" in the resulting dataframe
contains another dataframe. We access it like we normally would access a 
column in a dataframe:

```{r}
subject$subjects
```

Those sub-subjects have their own subjects! Lets get to the bottom of this:

```{r}
sub_sub_subjects <- get_subjects("2401")
sub_sub_subjects$subjects
```
get_subjects is able to retrieve all the sub, sub-sub and sub-sub-sub-jects in
one go. The result is a bit confusing and difficult to navigate.

Remember that the initial result was a dataframe containing another dataframe.
If we go all the way to the bottom, we will get a dataframe, containing several
dataframes, each of those containing several dataframes. 

We recommend that you do not try it, but this is how it is done:
```{r}
lots_of_subjects <- get_subjects("02", recursive = T, include_tables = T)
```

For each of the final subjects, there are several tables available, containing data.

How do we find out which tables exists?

The get_tables() function returns a dataframe with information about the 
tables available for a given subject.


```{r}
tables <- get_tables(subjects="10021")
tables
```
We get at lot of information here. The id identifies the table, text gives a 
description of the table that humans can understand. When the table was last
updated and the first and last period that the table contains data for.

In the variables column, we get information on what kind of data is stored in 
the table.



```{r}
metadata <- get_table_metadata("FOLK1A", variables_only = T)
metadata
```

There is a lot of other metadata in the tables, including the phone number to 
the staffmember at Statistics Denmark that is responsible for maintaining the
table. We are only interested in the variables. 

What kind of values can the individual datapoints take?

```{r}
metadata %>% slice(4) %>% pull(values)
```

We use the slice function from tidyverse to pull out the fourth row of the 
dataframe, and the pull-function to pull out the values in the values
column.

The same trick can be done for the other fields in the table:

```{r}
metadata %>% slice(1) %>% pull(values)
```
Here we see the individual municipalities in Denmark. And a handfull of 
aggregate numbers.

Now we are almost ready to pull out the actual data!


```{r}
get_data()
```



get_subjects provides information on the different tables available from 
Statistics Denmark. If we drill down to a specific table, let us use
10021 - Population in Denmark, what kind of information does it contain?

```{r}
danstat::get_tables() %>% view()
```

When we access a website


a set of commands that we can send to an application. And we are
told what we can expect from the remote application, if we send a specific 
command to it.

We need to send our commands in a very specific way to t

